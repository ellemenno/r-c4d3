
/*
main build file for r-c4d3 multiproject

includes utility methods for use across subprojects
subprojects are denoted in settings.gradle (same directory as this file)
*/

// note to gradle that projects included by settings.gradle need things from this file
childrenDependOnMe()

version = '001'
dependsOn(':framework')
defaultTasks 'build'

//announceBegin("[r-c4d3] v.$version")
//println('- subprojects:')
//allprojects { println "- $name from '$path'" }
//println('- - - - - - - - - - - - - - -')



task build << {
	Task task ->
	announceBegin("[r-c4d3] v.$version")
}



/*
reusable utility methods for sub-projects
*/

def announceBegin(title) {
println"""
- - - - - - - - - - - - - - -
- $title\
"""
}

def announceEnd(title) {
println"""
- $title done
- - - - - - - - - - - - - - -\
"""
}

def env() {
	println "[r-c4d3] System properties known to Gradle:"
	System.properties.each { println it }
}

def sysDelim () {
	return File.separator
}

def sysPath(path) {
	path.replace('/', File.separator)
}
def frameworkSwcPath() {
	return rootProject.projectDir.path +sysPath("/framework/target/r-c4d3.swc")
}

def exec (project, command, subPath='') {
	// compose command and execution directory
	println "exec() command: '${command}'"
	subPath = (subPath == '') ? subPath : sysPath("/$subPath")
	def execDir = new File(project.projectDir.path +subPath)
	println "- from $execDir"
	
	// execute command and wait for result
	outStream = new StringBuffer()
	errStream = new StringBuffer()
	def proc = command.execute(null, execDir) // execute from project directory so relative pathing is sensible
	proc.consumeProcessOutput(outStream, errStream)  // Groovy way of preventing waitFor() hang
	proc.waitFor()

	// obtain status and output
	println "exec.stdout:\n${proc.in.text.trim()}" // *out* from the external program is *in* for groovy
	println "exec.return-code: ${proc.exitValue()}"
	if (proc.exitValue() != 0) {
		println "exec.stderr: ${proc.err.text.trim()}"
		throw new RuntimeException('command execution failed')
	}
	else println "exec.success"
}

def cleanTarget (project, subPath='') {
	def targetDir = project.projectDir.path +sysPath("/target/$subPath")
	println "- cleanTarget(${project.name}) - removing and recreating $targetDir"
	ant.delete(dir: targetDir)
	ant.mkdir(dir: targetDir)
	return targetDir
}

def compileMxmlc (project, config, main, mainPath='src/main') {
	def input = project.projectDir.path +sysPath("/$mainPath/actionscript/$main")
	input += " -load-config+=${project.projectDir.path}" +sysPath("/$mainPath/config/$config")
	println "- compileMxmlc(${project.name}, $main) - compiling $main"
	exec(project, "mxmlc ${input}")
}

def compileAsdoc (project, config, mainPath='src/main') {
	def input = "-load-config+=${project.projectDir.path}" +sysPath("/$mainPath/config/$config")
	println "- compileAsdoc(${project.name}, $config) - loading config from $config"
	exec(project, "asdoc ${input}")
}

def compileCompc (project, config, mainPath='src/main') {
	def input = "-load-config+=${project.projectDir.path}" +sysPath("/$mainPath/config/$config")
	println "- compileCompc(${project.name}, $config) - loading config from $config"
	exec(project, "compc ${input}")
}

def createHxClasses (project, lib) {
	def D = sysDelim()
	def targetRoot = project.projectDir.path +D +"target"
	def haxe = targetRoot +D +"haxe"
	def zipSrc = targetRoot +D +lib
	def temp = haxe +D +"temp"
	def swfName = "library.swf"
	def command = "haxe --gen-hx-classes $haxe$D$swfName"
	
	println "- createHxClasses(${project.name}, $lib) - extracting hxclasses from $lib"
	println "- unzipping $zipSrc into $temp"
	ant.unzip(src:zipSrc, dest:temp)
	println "- moving $temp$D$swfName into $haxe"
	ant.move(file:temp+D+swfName, todir:haxe)
	println "- exec $command"
	exec(project, command, "target/haxe")
	println "- deleting $temp"
	ant.delete(dir:temp)
}

